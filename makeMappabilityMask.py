#!/usr/bin/env python3

# This script was originally copied from the following repository:
#	https://github.com/stschiff/msmc-tools
# It was called makeMappabilityMask.py, and was authored by
# Stephan Schiffels and Daniel Weissman. It was downloaded from
# commit #123791f. No license was specified on the public repo.
# If you use, extend, or modify this script, please give
# appropriate credit to these original authors.
# 
# Brandon Pickett modified this script to provide additional
# flexibility and argument handling. Python v3.6+ is required
# due to the use of f-strings.

# ----------- IMPORTS ---------------------------- ||
import sys
import gzip
import argparse
from pathlib import Path

# ----------- CLASSES ---------------------------- ||
class MaskGenerator:
	def __init__(self, filename, chrom):
		self.lastCalledPos = -1
		self.lastStartPos = -1
		sys.stderr.write("making mask {}\n".format(filename))
		open_method = gzip.open if filename.endswith(".gz") else open
		open_mode = "wt" if filename.endswith(".gz") else 'w'
		self.file = open_method(filename, open_mode)
		self.chrom = chrom
  
	# assume 1-based coordinate, output in bed format
	def addCalledPosition(self, pos):
		if self.lastCalledPos == -1:
			self.lastCalledPos = pos
			self.lastStartPos = pos
		elif pos == self.lastCalledPos + 1:
			self.lastCalledPos = pos
		else:
			self.file.write(f"{self.chrom}\t{self.lastStartPos - 1}\t{self.lastCalledPos}\n")
			self.lastStartPos = pos
			self.lastCalledPos = pos

# ---------- FUNCTIONS --------------------------- ||
def handleArgs():
	# define the main argument parser
	parser = argparse.ArgumentParser(prog=Path(sys.argv[0]).name, add_help=False, allow_abbrev=True, description="This program will take a SNPability mask (fasta format) and convert it into bed format with one output file per sequence.")

	# define argument groups
	input_group = parser.add_argument_group("Input Options", "These options affect how input files are found and/or interpreted.")
	output_group = parser.add_argument_group("Output Options", "These options affect which and how output files are generated. Since one ouptut file will be created per input \"sequence\" in the input fasta file, the output files need a naming scheme. They will all be in the output directory and named after the following pattern: <prefix><header><suffix>. The <header> comes from the input fasta file; <prefix> and <suffix> are defined with arguments.")
	misc_group = parser.add_argument_group("Misc. Options", "")

	# define input group options
	input_group.add_argument("-i", "--input-fasta", dest="input_fasta", metavar="path/to/input/mask_35_50.fa", action="store", type=str, required=True, help="This is the input mask file generated by SNPable. Note the SNPable generates two mask files. The first is a 'raw' mask from which the primary mask is made. This is expecting the primary (i.e., not raw) mask. This file must be in fasta format; it may be gzipped.")

	# define output group options
	output_group.add_argument("-d", "-od", "--output-dir", dest="output_dir", metavar="path/to/output_dir", action="store", type=str, required=False, default="data/assembly/SNPable_mask", help="One output file will be created per input \"sequence\" in the input fasta file. This argument tells the program where these files should be located. [data/assembly/SNPable_mask]")
	output_group.add_argument("-o", "-op", "--output-prefix", dest="output_prefix", metavar="mask_", action="store", type=str, required=False, default="mask_", help="This defines the <prefix> portion of the output file names. [mask_]")
	output_group.add_argument("-s", "-os", "--output-suffix", dest="output_suffix", metavar=".bed.gz", action="store", type=str, required=False, default=".bed.gz", help=" This defines the <suffix> portion of the output file names. The file will be gzipped if it ends in \".gz\". [.bed.gz]")

	# define misc. group options
	misc_group.add_argument("-h", "--help", action="help", help="Show this help message and exit.")
	
	# parse the arguments
	args = parser.parse_args()

	# return the parsed arguments object
	return args

# ------------- MAIN ----------------------------- ||
if __name__ == "__main__":

	# parse the arguments
	args = handleArgs()

	# determine some important things before we start
	input_open = open
	input_open_mode = 'r'
	if args.input_fasta.endswith(".gz"):
		input_open = gzip.open
		input_open_mode = "rt"

	with input_open(args.input_fasta, input_open_mode) as f:
		line = f.readline()
		while line != '':
			header = line.split()[0][1:]
			seq = ''
			line = f.readline()
			while line != '' and not line.startswith('>'):
				seq += line.rstrip('\n')
				line = f.readline()
			output_file = Path(f"{args.output_dir}") / Path(f"{args.output_prefix}{header}{args.output_suffix}")
			mask = MaskGenerator(str(output_file), header)
			pos = 0
			for c in seq:
				pos += 1
				if pos % 1000000 == 0:
					sys.stderr.write(f"processing pos:{pos}\n")
				if c == "3":
					mask.addCalledPosition(pos)

